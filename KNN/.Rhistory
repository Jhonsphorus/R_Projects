preProcess_missingdata_model
# Use the imputation model to predict the values of missing data points
#library(RANN)  # required for knnInpute
trainData <- predict(preProcess_missingdata_model, newdata = trainData)
anyNA(trainData)
View(trainData)
myname <- "Johnson"
paste(myname, "=")
paste(myname, "is", "myname")
cat(myname, "is", "my name")
# One-Hot Encoding
# Creating dummy variables is converting a categorical variable to as many binary variables as here are categories.
dummies_model <- dummyVars(Purchase ~ ., data=trainData)
# Create the dummy variables using predict. The Y variable (Purchase) will not be present in trainData_mat.
trainData_mat <- predict(dummies_model, newdata = trainData)
# # Convert to dataframe
trainData <- data.frame(trainData_mat)
# # See the structure of the new dataset
str(trainData)
View(trainData)
preProcess_range_model <- preProcess(trainData, method='range')
trainData <- predict(preProcess_range_model, newdata = trainData)
View(trainData)
preProcess_range_model <- preProcess(trainData, method='range')
trainData <- predict(preProcess_range_model, newdata = trainData)
# Append the Y variable
trainData$Purchase <- y # Adding the response variable back to the trainData
View(trainData)
#View(trainData)
apply(trainData[, 1:10], 2, FUN=function(x){c('min'=min(x), 'max'=max(x))})
str(trainData)
# str(trainData)
featurePlot(x = trainData[, 1:18], y = trainData$Purchase, plot = "box")
featurePlot(x = trainData[, 1:18],
y = trainData$Purchase,
plot = "box",
strip=strip.custom(par.strip.text=list(cex=.7)),
scales = list(x = list(relation="free"),
y = list(relation="free")))
featurePlot(x = trainData[, 1:18],
y = trainData$Purchase,
plot = "line",
strip=strip.custom(par.strip.text=list(cex=.7)),
scales = list(x = list(relation="free"),
y = list(relation="free")))
featurePlot(x = trainData[, 1:18],
y = trainData$Purchase,
plot = "hist",
strip=strip.custom(par.strip.text=list(cex=.7)),
scales = list(x = list(relation="free"),
y = list(relation="free")))
featurePlot(x = trainData[, 1:18],
y = trainData$Purchase,
plot = "box",
strip=strip.custom(par.strip.text=list(cex=.7)),
scales = list(x = list(relation="free"),
y = list(relation="free")))
featurePlot(x = trainData[, 1:18], y = trainData$Purchase, plot = "density", strip=strip.custom(par.strip.text=list(cex=.7)),scales = list(x = list(relation="free"), y = list(relation="free")))
?rfe
set.seed(100)
options(warn=-1)
subsets <- c(1:5, 10, 15, 18)
ctrl <- rfeControl(functions = rfFuncs,method = "repeatedcv",repeats = 5,verbose = FALSE)
lmProfile <- rfe(x=trainData[, 1:18], y=trainData$Purchase,sizes = subsets,rfeControl = ctrl)
lmProfile
# See available algorithms in caret
modelnames <- paste(names(getModelInfo()), collapse=',  ')
modelnames
# See available algorithms in caret
#modelnames <- paste(names(getModelInfo()), collapse=',  ')
modelnames <- paste("'",names(getModelInfo()),  "'")
modelnames
# See available algorithms in caret
modelnames <- paste(names(getModelInfo()), collapse=',  ')
modelnames
getModelInfo()
modelLookup(rf)
modelLookup('rf')
modelLookup('glm')
modelLookup('earth')
modelLookup('lm')
modelLookup('logicBag')
# Set the seed for reproducibility
set.seed(100)
# Train the model using randomForest and predict on the training data itself.
model_mars = train(Purchase ~ ., data=trainData, method='earth')
fitted <- predict(model_mars)
model_mars
fitted
plot(model_mars, main="Model Accuracies with MARS")
varimp_mars <- varImp(model_mars)
plot(varimp_mars, main="Variable Importance with MARS")
# Step 1: Impute missing values
testData2 <- predict(preProcess_missingdata_model, testData)
# Step 2: Create one-hot encodings (dummy variables)
testData3 <- predict(dummies_model, testData2)
# Step 3: Transform the features to range between 0 and 1
testData4 <- predict(preProcess_range_model, testData3)
# View
head(testData4[, 1:10])
View(testData4)
# Predict on testData
predicted <- predict(model_mars, testData4)
head(predicted)
confusionMatrix(reference = testData$Purchase, data = predicted, mode='everything', positive='MM')
confusionMatrix(reference = testData$Purchase, data = predicted, mode='everything', positive='CH')
# Step 1: Impute missing values
testData2 <- predict(preProcess_missingdata_model, testData)
# Step 2: Create one-hot encodings (dummy variables)
testData3 <- predict(dummies_model, testData2)
testData3 <- data.frame(testData3)
# Step 3: Transform the features to range between 0 and 1
testData4 <- predict(preProcess_range_model, testData3)
# View
head(testData4[, 1:10])
#View(testData4)
# Predict on testData
predicted <- predict(model_mars, testData4)
head(predicted)
#confusionMatrix(reference = testData$Purchase, data = predicted, mode='everything', positive='MM')
confusionMatrix(predicted, testData$Purchase )
#confusionMatrix(reference = testData$Purchase, data = predicted, mode='everything', positive='MM')
confusionMatrix(predicted, testData$Purchase, positive='MM' )
#confusionMatrix(reference = testData$Purchase, data = predicted, mode='everything', positive='MM')
confusionMatrix(testData$Purchase, predicted,  positive='MM' )
#confusionMatrix(reference = testData$Purchase, data = predicted, mode='everything', positive='MM')
confusionMatrix(predicted, testData$Purchase, positive='MM' )
# Step 1: Impute missing values
testData2 <- predict(preProcess_missingdata_model, testData)
# Step 2: Create one-hot encodings (dummy variables)
testData3 <- predict(dummies_model, testData2)
#testData3 <- data.frame(testData3) # This is optional
# Step 3: Transform the features to range between 0 and 1
testData4 <- predict(preProcess_range_model, testData3)
# View
head(testData4[, 1:10])
#View(testData4)
# Predict on testData
predicted <- predict(model_mars, testData4)
head(predicted)
#confusionMatrix(reference = testData$Purchase, data = predicted, mode='everything', positive='MM')
confusionMatrix(predicted, testData$Purchase, positive='MM' )
confusionMatrix(reference = testData$Purchase, data = predicted, mode='everything', positive='MM')
#confusionMatrix(predicted, testData$Purchase, positive='MM' )
confusionMatrix(reference = testData$Purchase, data = predicted, mode='everything', positive='MM')
#confusionMatrix(predicted, testData$Purchase, positive='MM' )
# Set the seed for reproducibility
set.seed(10)
# Train the model using randomForest and predict on the training data itself.
model_mars = train(Purchase ~ ., data=trainData, method='earth')
fitted <- predict(model_mars)
plot(model_mars, main="Model Accuracies with MARS")
varimp_mars <- varImp(model_mars)
plot(varimp_mars, main="Variable Importance with MARS")
# Step 1: Impute missing values
testData2 <- predict(preProcess_missingdata_model, testData)
# Step 2: Create one-hot encodings (dummy variables)
testData3 <- predict(dummies_model, testData2)
#testData3 <- data.frame(testData3) # This is optional
# Step 3: Transform the features to range between 0 and 1
testData4 <- predict(preProcess_range_model, testData3)
# View
head(testData4[, 1:10])
#View(testData4)
# Predict on testData
predicted <- predict(model_mars, testData4)
head(predicted)
confusionMatrix(reference = testData$Purchase, data = predicted, mode='everything', positive='MM')
#confusionMatrix(predicted, testData$Purchase, positive='MM' )
# Predict on testData
predicted <- predict(model_mars, testData4)
head(predicted)
confusionMatrix(reference = testData$Purchase, data = predicted, mode='everything', positive='MM')
#confusionMatrix(predicted, testData$Purchase, positive='MM' )
# Step 1: Impute missing values
testData2 <- predict(preProcess_missingdata_model, testData)
# Step 2: Create one-hot encodings (dummy variables)
testData3 <- predict(dummies_model, testData2)
#testData3 <- data.frame(testData3) # This is optional
# Step 3: Transform the features to range between 0 and 1
testData4 <- predict(preProcess_range_model, testData3)
# View
head(testData4[, 1:10])
#View(testData4)
# Predict on testData
predicted <- predict(model_mars, testData4)
head(predicted)
confusionMatrix(reference = testData$Purchase, data = predicted, mode='everything', positive='MM')
#confusionMatrix(predicted, testData$Purchase, positive='MM' )
# Step 1: Impute missing values
testData2 <- predict(preProcess_missingdata_model, testData)
# Step 2: Create one-hot encodings (dummy variables)
testData3 <- predict(dummies_model, testData2)
testData3 <- data.frame(testData3) # This is optional
# Step 3: Transform the features to range between 0 and 1
testData4 <- predict(preProcess_range_model, testData3)
# View
head(testData4[, 1:10])
#View(testData4)
# Predict on testData
predicted <- predict(model_mars, testData4)
head(predicted)
confusionMatrix(reference = testData$Purchase, data = predicted, mode='everything', positive='MM')
#confusionMatrix(predicted, testData$Purchase, positive='MM' )
# Set the seed for reproducibility
set.seed(105)
# Train the model using randomForest and predict on the training data itself.
model_mars = train(Purchase ~ ., data=trainData, method='earth')
fitted <- predict(model_mars)
model_mars
plot(model_mars, main="Model Accuracies with MARS")
# Step 1: Impute missing values
testData2 <- predict(preProcess_missingdata_model, testData)
# Step 2: Create one-hot encodings (dummy variables)
testData3 <- predict(dummies_model, testData2)
testData3 <- data.frame(testData3) # This is optional
# Step 3: Transform the features to range between 0 and 1
testData4 <- predict(preProcess_range_model, testData3)
# View
head(testData4[, 1:10])
#View(testData4)
# Predict on testData
predicted <- predict(model_mars, testData4)
head(predicted)
confusionMatrix(reference = testData$Purchase, data = predicted, mode='everything', positive='MM')
#confusionMatrix(predicted, testData$Purchase, positive='MM' )
set.seed(100)
options(warn=-1)
subsets <- c(1:5, 10, 15, 18)
ctrl <- rfeControl(functions = rfFuncs,method = "repeatedcv",repeats = 5,verbose = FALSE)
lmProfile <- rfe(x=trainData[, 1:18], y=trainData$Purchase,sizes = subsets,rfeControl = ctrl)
lmProfile
#dtURL <- 'https://raw.githubusercontent.com/selva86/datasets/master/orange_juice_withmissing.csv'
#download.file(url = dtURL, destfile = "orange_juice_withmissing.csv")
orange1 <- read.csv("orange_juice_withmissing.csv", header = TRUE)
#View(orange1)
str(orange1)
# Create the training and test datasets
set.seed(100) # To replicate the same values of test and training dataset
# Step 1: Get row numbers for the training data
trainRowNumbers <- createDataPartition(orange1$Purchase, p=0.8, list=FALSE)
# Step 2: Create the training  dataset
trainData <- orange1[trainRowNumbers,]
# Step 3: Create the test dataset
testData <- orange1[-trainRowNumbers,]
# Store X and Y for later use.
x = trainData[, 2:18] # Predictor variables for the training
y = trainData$Purchase # Response variable for y
#library(skimr)
skimmed <- skim_to_wide(trainData)
skimmed[, c(1:5, 9:11, 13, 15)]
#library(caret) # The package that housed preProcess() function
# Create the knn imputation model on the training data
#preProcess_missingdata_model <- preProcess(trainData, method='bagImpute') # Alternative method
preProcess_missingdata_model <- preProcess(trainData, method='knnImpute')
preProcess_missingdata_model
# Use the imputation model to predict the values of missing data points
#library(RANN)  # required for knnInpute
trainData <- predict(preProcess_missingdata_model, newdata = trainData)
anyNA(trainData)
# One-Hot Encoding
# Creating dummy variables is converting a categorical variable to as many binary variables as here are categories.
dummies_model <- dummyVars(Purchase ~ ., data=trainData)
# Create the dummy variables using predict. The Y variable (Purchase) will not be present in trainData_mat.
trainData_mat <- predict(dummies_model, newdata = trainData)
# # Convert to dataframe
trainData <- data.frame(trainData_mat) # Converting the result above to dataframe
# # See the structure of the new dataset
str(trainData)
preProcess_range_model <- preProcess(trainData, method='range')
trainData <- predict(preProcess_range_model, newdata = trainData)
# Append the Y variable
trainData$Purchase <- y # Adding the response variable (column) back to the trainData
#View(trainData)
# Confirming the range of all the predictors
apply(trainData[, 1:10], 2, FUN=function(x){c('min'=min(x), 'max'=max(x))})
featurePlot(x = trainData[, 1:18], y = trainData$Purchase, plot = "box")
featurePlot(x = trainData[, 1:18],
y = trainData$Purchase,
plot = "box",
strip=strip.custom(par.strip.text=list(cex=.7)),
scales = list(x = list(relation="free"),
y = list(relation="free")))
set.seed(100)
options(warn=-1)
subsets <- c(1:5, 10, 15, 18)
ctrl <- rfeControl(functions = rfFuncs,method = "repeatedcv",repeats = 5,verbose = FALSE)
lmProfile <- rfe(x=trainData[, 1:18], y=trainData$Purchase,sizes = subsets,rfeControl = ctrl)
lmProfile
# Set the seed for reproducibility
set.seed(100)
# Train the model using randomForest and predict on the training data itself.
model_mars = train(Purchase ~ ., data=trainData, method='earth')
fitted <- predict(model_mars)
model_mars
plot(model_mars, main="Model Accuracies with MARS")
varimp_mars <- varImp(model_mars)
plot(varimp_mars, main="Variable Importance with MARS")
# Step 1: Impute missing values
testData2 <- predict(preProcess_missingdata_model, testData)
# Step 2: Create one-hot encodings (dummy variables)
testData3 <- predict(dummies_model, testData2)
#testData3 <- data.frame(testData3) # This is optional
# Step 3: Transform the features to range between 0 and 1
testData4 <- predict(preProcess_range_model, testData3)
# View
head(testData4[, 1:10])
#View(testData4)
# Predict on testData
predicted <- predict(model_mars, testData4)
head(predicted)
confusionMatrix(reference = testData$Purchase, data = predicted, mode='everything', positive='MM')
#confusionMatrix(predicted, testData$Purchase, positive='MM' )
# Define the training control
fitControl <- trainControl(
method = 'cv',                   # k-fold cross validation
number = 5,                      # number of folds
savePredictions = 'final',       # saves predictions for optimal tuning parameter
classProbs = T,                  # should class probabilities be returned
summaryFunction=twoClassSummary  # results summary function
)
# Step 1: Tune hyper parameters by setting tuneLength
set.seed(100)
model_mars2 = train(Purchase ~ ., data=trainData, method='earth', tuneLength = 5, metric='ROC', trControl = fitControl)
model_mars2
# Step 2: Predict on testData and Compute the confusion matrix
predicted2 <- predict(model_mars2, testData4)
confusionMatrix(reference = testData$Purchase, data = predicted2, mode='everything', positive='MM')
# Step 1: Tune hyper parameters by setting tuneLength
set.seed(100)
model_mars2 = train(Purchase ~ ., data=trainData, method='earth', tuneLength = 5, metric='Accuracy', trControl = fitControl)
model_mars2
# Step 2: Predict on testData and Compute the confusion matrix
predicted2 <- predict(model_mars2, testData4)
confusionMatrix(reference = testData$Purchase, data = predicted2, mode='everything', positive='MM')
# Step 1: Tune hyper parameters by setting tuneLength
set.seed(100)
model_mars2 = train(Purchase ~ ., data=trainData, method='earth', tuneLength = 10, metric='ROC', trControl = fitControl)
model_mars2
# Step 2: Predict on testData and Compute the confusion matrix
predicted2 <- predict(model_mars2, testData4)
confusionMatrix(reference = testData$Purchase, data = predicted2, mode='everything', positive='MM')
# Step 1: Tune hyper parameters by setting tuneLength
set.seed(100)
model_mars2 = train(Purchase ~ ., data=trainData, method='earth', tuneLength = 5, metric='ROC', trControl = fitControl)
model_mars2
# Step 2: Predict on testData and Compute the confusion matrix
predicted2 <- predict(model_mars2, testData4)
confusionMatrix(reference = testData$Purchase, data = predicted2, mode='everything', positive='MM')
# Step 1: Tune hyper parameters by setting tuneLength
set.seed(100)
model_mars2 = train(Purchase ~ ., data=trainData, method='earth', tuneLength = 5, metric='ROC', trControl = fitControl, degree=1 )
# Step 1: Tune hyper parameters by setting tuneLength
set.seed(100)
model_mars2 = train(Purchase ~ ., data=trainData, method='earth', tuneLength = 5, metric='ROC', trControl = fitControl, degree=3 )
# Step 1: Tune hyper parameters by setting tuneLength
set.seed(100)
model_mars2 = train(Purchase ~ ., data=trainData, method='earth', tuneLength = 5, metric='ROC', trControl = fitControl, degree= c(1,2,3) )
# Step 1: Tune hyper parameters by setting tuneLength
set.seed(100)
model_mars2 = train(Purchase ~ ., data=trainData, method='earth', tuneLength = 5, metric='ROC', trControl = fitControl )
model_mars2
# Step 2: Predict on testData and Compute the confusion matrix
predicted2 <- predict(model_mars2, testData4)
confusionMatrix(reference = testData$Purchase, data = predicted2, mode='everything', positive='MM')
# Step 1: Define the tuneGrid
marsGrid <-  expand.grid(nprune = c(2, 4, 6, 8, 10),
degree = c(1, 2, 3))
# Step 2: Tune hyper parameters by setting tuneGrid
set.seed(100)
model_mars3 = train(Purchase ~ ., data=trainData, method='earth', metric='ROC', tuneGrid = marsGrid, trControl = fitControl)
model_mars3
# Step 3: Predict on testData and Compute the confusion matrix
predicted3 <- predict(model_mars3, testData4)
confusionMatrix(reference = testData$Purchase, data = predicted3, mode='everything', positive='MM')
# Step 1: Define the tuneGrid
marsGrid <-  expand.grid(nprune = c(2, 4, 6, 8, 10),
degree = c(1, 2, 3))
# Step 2: Tune hyper parameters by setting tuneGrid
set.seed(1000)
model_mars3 = train(Purchase ~ ., data=trainData, method='earth', metric='ROC', tuneGrid = marsGrid, trControl = fitControl)
model_mars3
# Step 3: Predict on testData and Compute the confusion matrix
predicted3 <- predict(model_mars3, testData4)
confusionMatrix(reference = testData$Purchase, data = predicted3, mode='everything', positive='MM')
# Step 1: Define the tuneGrid
marsGrid <-  expand.grid(nprune = c(2, 4, 6, 8, 10), degree = c(1, 2, 3))
# Step 2: Tune hyper parameters by setting tuneGrid
set.seed(1500)
model_mars3 = train(Purchase ~ ., data=trainData, method='earth', metric='ROC', tuneGrid = marsGrid, trControl = fitControl)
model_mars3
# Step 3: Predict on testData and Compute the confusion matrix
predicted3 <- predict(model_mars3, testData4)
confusionMatrix(reference = testData$Purchase, data = predicted3, mode='everything', positive='MM')
# Step 1: Define the tuneGrid
marsGrid <-  expand.grid(nprune = c(2, 4, 6, 8, 10), degree = c(1, 2, 3))
# Step 2: Tune hyper parameters by setting tuneGrid
set.seed(15)
model_mars3 = train(Purchase ~ ., data=trainData, method='earth', metric='ROC', tuneGrid = marsGrid, trControl = fitControl)
model_mars3
# Step 3: Predict on testData and Compute the confusion matrix
predicted3 <- predict(model_mars3, testData4)
confusionMatrix(reference = testData$Purchase, data = predicted3, mode='everything', positive='MM')
# Step 1: Define the tuneGrid
marsGrid <-  expand.grid(nprune = c(2, 4, 6, 8, 10), degree = c(1, 2, 3, 4))
# Step 2: Tune hyper parameters by setting tuneGrid
set.seed(15)
model_mars3 = train(Purchase ~ ., data=trainData, method='earth', metric='ROC', tuneGrid = marsGrid, trControl = fitControl)
model_mars3
# Step 3: Predict on testData and Compute the confusion matrix
predicted3 <- predict(model_mars3, testData4)
confusionMatrix(reference = testData$Purchase, data = predicted3, mode='everything', positive='MM')
# Step 1: Define the tuneGrid
marsGrid <-  expand.grid(nprune = c(2, 4, 6, 8, 10), degree = c(1, 2, 3, 4))
# Step 2: Tune hyper parameters by setting tuneGrid
set.seed(1000)
model_mars3 = train(Purchase ~ ., data=trainData, method='earth', metric='ROC', tuneGrid = marsGrid, trControl = fitControl)
model_mars3
# Step 3: Predict on testData and Compute the confusion matrix
predicted3 <- predict(model_mars3, testData4)
confusionMatrix(reference = testData$Purchase, data = predicted3, mode='everything', positive='MM')
fitControl2 <- trainControl(method = 'repeatedcv', number = 5, repeats = 3)
# Step 1: Tune hyper parameters by setting tuneLength
set.seed(100)
model_mars2 = train(Purchase ~ ., data=trainData, method='earth', tuneLength = 5, metric='ROC', trControl = fitControl2 )
# Step 1: Tune hyper parameters by setting tuneLength
set.seed(100)
model_mars2 = train(Purchase ~ ., data=trainData, method='earth', tuneLength = 5, metric='Accuracy', trControl = fitControl2 )
model_mars2
# Step 2: Predict on testData and Compute the confusion matrix
predicted2 <- predict(model_mars2, testData4)
confusionMatrix(reference = testData$Purchase, data = predicted2, mode='everything', positive='MM')
# Step 1: Tune hyper parameters by setting tuneLength
set.seed(100)
model_mars2 = train(Purchase ~ ., data=trainData, method='earth', tuneLength = 5, metric='ROC', trControl = fitControl )
model_mars2
# Step 2: Predict on testData and Compute the confusion matrix
predicted2 <- predict(model_mars2, testData4)
confusionMatrix(reference = testData$Purchase, data = predicted2, mode='everything', positive='MM')
set.seed(100)
# Train the model using adaboost
model_adaboost = train(Purchase ~ ., data=trainData, method='adaboost', tuneLength=2, trControl = fitControl)
model_adaboost
pred_adaboost <- predict(model_adaboost, trainData)
confusionMatrix(pred_adaboost, trainData$Purchase)
pred_adaboost <- predict(model_adaboost, testData4)
confusionMatrix(pred_adaboost, testData$Purchase)
set.seed(100)
# Train the model using rf
model_rf = train(Purchase ~ ., data=trainData, method='rf', tuneLength=5, trControl = fitControl)
model_rf
pred_rf <- predict(model_rf, testData4)
confusionMatrix(pred_rf, testData$Purchase)
pred_adaboost <- predict(model_adaboost, testData4, positive='MM')
confusionMatrix(pred_adaboost, testData$Purchase)
pred_adaboost <- predict(model_adaboost, testData4)
confusionMatrix(pred_adaboost, testData$Purchase, positive='MM')
set.seed(100)
# Train the model using rf
model_rf = train(Purchase ~ ., data=trainData, method='rf', tuneLength=5, trControl = fitControl)
model_rf
pred_rf <- predict(model_rf, testData4)
confusionMatrix(pred_rf, testData$Purchase, positive='MM')
set.seed(100)
# Train the model using MARS
model_xgbDART = train(Purchase ~ ., data=trainData, method='xgbDART', tuneLength=5, trControl = fitControl, verbose=F)
model_xgbDART
pred_xgb <- predict(model_xgbDART, testData4)
confusionMatrix(pred_xgb, testData$Purchase)
pred_xgb <- predict(model_xgbDART, testData4)
confusionMatrix(pred_xgb, testData$Purchase, positive = "MM")
set.seed(100)
# Train the model using MARS
model_svmRadial = train(Purchase ~ ., data=trainData, method='svmRadial', tuneLength=15, trControl = fitControl)
model_svmRadial
pred_svm <- predict(model_svmRadial, testData4)
confusionMatrix(pred_svm, testData$Purchase)
# Compare model performances using resample()
models_compare <- resamples(list(ADABOOST=model_adaboost, RF=model_rf, XGBDART=model_xgbDART, MARS=model_mars3, SVM=model_svmRadial))
# Summary of the models performances
summary(models_compare)
# Draw box plots to compare models
scales <- list(x=list(relation="free"), y=list(relation="free"))
bwplot(models_compare, scales=scales)
?resamples
library(caretEnsemble)
# Stacking Algorithms - Run multiple algos in one call.
trainControl <- trainControl(method="repeatedcv", number=10, repeats=3, savePredictions=TRUE, classProbs=TRUE)
algorithmList <- c('rf', 'adaboost', 'earth', 'xgbDART', 'svmRadial')
set.seed(100)
models <- caretList(Purchase ~ ., data=trainData, trControl=trainControl, methodList=algorithmList)
results <- resamples(models)
summary(results)
# Draw box plots to compare models
scales <- list(x=list(relation="free"), y=list(relation="free"))
bwplot(models, scales=scales)
# Draw box plots to compare models
scales <- list(x=list(relation="free"), y=list(relation="free"))
bwplot(results, scales=scales)
bwplot(c(model_adaboost, model_xgbDART), scales=scales)
# Create the trainControl
set.seed(101)
stackControl <- trainControl(method="repeatedcv", number=10, repeats=3, savePredictions=TRUE, classProbs=TRUE)
# Ensemble the predictions of `models` to form a new combined prediction based on glm
stack.glm <- caretStack(models, method="glm", metric="Accuracy", trControl=stackControl)
print(stack.glm)
# Predict on testData
stack_predicteds <- predict(stack.glm, newdata=testData4)
head(stack_predicteds)
confusionMatrix(stack_predicteds, testData$Purchase)
confusionMatrix(stack_predicteds, testData$Purchase, positive = 'MM')
library(caret)
